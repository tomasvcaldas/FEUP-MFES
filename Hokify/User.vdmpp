class User
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
		firstName: seq of char;
		lastName: seq of char;
		email: seq of char;
		phonenumber: nat;
		curriculumVitae : [CV] := nil;
		appliances: set of JobOffer; 
		
operations

public User: seq of char * seq of char * seq of char * nat  ==> User
User(fName,lName,e,p) == (
				firstName := fName;
				lastName := lName;
				email := e;
				phonenumber := p;
				appliances := {};
);

			public createCV : () ==> ()
				createCV() ==
				curriculumVitae := new CV(firstName, lastName,email, nil, {});
				
			public offerMatches : JobOffer ==> bool
			offerMatches(offer) ==
			return (offer.getRequiredDriversLicense() = nil or curriculumVitae.getDriversLicense() = offer.getRequiredDriversLicense()) and
			(offer.getRequiredEducation() = {} or offer.getRequiredEducation() inter curriculumVitae.getEducation() <> {}) and
			(offer.getNeededSkills() = {} or card (curriculumVitae.getSkills() inter offer.getNeededSkills()) / card offer.getNeededSkills() > 0.5);
			
			public getMatchingOffers: set of JobOffer ==> set of JobOffer 
				getMatchingOffers(offers) ==
				(dcl validJobs : set of JobOffer := {};
				for all offer in set offers do
					if offerMatches(offer)
					then validJobs := validJobs union {offer};
				return validJobs
				)
				pre curriculumVitae <> nil;
					

			pure public getFirstName: () ==> seq of char
				getFirstName() ==
 				 return firstName;
		
			pure public getLastName: () ==> seq of char
				getLastName()  ==
				return lastName;
				
			pure public getEmail: () ==> seq of char
				getEmail()  ==
				return email;
				
			pure public getPhoneNumber: () ==> nat
				getPhoneNumber()  ==
				return phonenumber;
										
			pure public getCV: () ==> [CV]
				getCV()  ==
				return curriculumVitae;
				
			pure public getAppliances: () ==> set of JobOffer
				getAppliances() ==
				return appliances;
	
			public addPastJob : PastJob ==> ()
				addPastJob(j) == 
				curriculumVitae.addPastJob(j)
				pre curriculumVitae <> nil and 
				not exists job in set curriculumVitae.getWorkExperience() &
				PastJob`areEqual(job, j);
				
			public removePastJob : PastJob ==> ()
				removePastJob(j) ==
				curriculumVitae.removePastJob(j)
				pre curriculumVitae <> nil and 
				exists job in set curriculumVitae.getWorkExperience() &
				PastJob`areEqual(job, j);

			public addSkill : seq of char ==> ()
				addSkill(s) == 
				curriculumVitae.addSkill(s);
				
			public removeSkill : seq of char ==> ()
				removeSkill(s) ==
				curriculumVitae.removeSkill(s);		

			public addHobbie : seq of char ==> ()
				addHobbie(h) == 
				curriculumVitae.addHobbie(h);
				
			public removeHobbie : seq of char ==> ()
				removeHobbie(h) ==
				curriculumVitae.removeHobbie(h);	
				
			public setDriversLicense : CV`DriversLicense ==> ()
				setDriversLicense(license) ==
				curriculumVitae.setDriversLicense(license);
				
			public addEducation : CV`Education ==> ()
				addEducation(edu) ==
				curriculumVitae.addEducation(edu);
				
			public applyForJob : JobOffer ==> ()
			applyForJob(j) ==
			(
				appliances := appliances union {j};
				j.addAppliance(self);
			);
			
			public declinedJob : JobOffer ==> ()
			declinedJob(job) ==
			(
				appliances := appliances \ {job};
			);
			
			public acceptedJob : JobOffer ==> ()
			acceptedJob(job) ==
			(
				appliances := appliances \ {job};
				curriculumVitae.addPastJob(new PastJob(job.getCompany(), job.getPosition(), mk_Job`Date(2018, 01, 03), nil));
			);
						
functions

public areEqual : User * User -> bool
areEqual(u1, u2) ==
		u1.email = u2.email;

traces
-- TODO Define Combinatorial Test Traces here
end User