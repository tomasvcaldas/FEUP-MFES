class JobOffer is subclass of Job
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
	
	openPositions: nat;
	appliances: set of User;
	neededSkills: set of seq of char;
	requiredEducation: set of CV`Education;
	requiredDriversLicense: [CV`DriversLicense];
	
operations
-- TODO Define operations here
public JobOffer : seq of char * seq of char * nat * set of seq of char * set of CV`Education * [CV`DriversLicense] ==> JobOffer
JobOffer(c, p, openPos, skills, reqEdu, reqLicense) == (
        openPositions := openPos;
        appliances := {};
        neededSkills := skills;
        requiredEducation := reqEdu;
        requiredDriversLicense := reqLicense;
        Job(c, p);
);

pure public getOpenPositions: () ==> nat
        getOpenPositions()  ==
        return openPositions;
        
pure public getAppliances: () ==> set of User
        getAppliances()  ==
        return appliances;
        
pure public getNeededSkills: () ==> set of seq of char
        getNeededSkills()  ==
        return neededSkills;
        
pure public getRequiredEducation: () ==> set of CV`Education
        getRequiredEducation()  ==
        return requiredEducation;
    
pure public getRequiredDriversLicense: () ==> [CV`DriversLicense]
        getRequiredDriversLicense()  ==
        return requiredDriversLicense;
        
public addAppliance : User ==> ()
        addAppliance(user) ==
        appliances := appliances union {user}
        pre user not in set appliances
        post user in set appliances;
        
public removeAppliance : User ==> ()
        removeAppliance(user) ==
        appliances := appliances \ {user}
        pre user in set appliances
        post user not in set appliances;
        
public getMatchingOffers: set of User ==> set of User 
getMatchingOffers(users) ==
				(dcl validCandidates : set of User := {};
				for all user in set users do
					if neededSkills = {} or 
					(user.getCV() <> nil and card (user.getCV().getSkills() inter neededSkills) / card neededSkills > 0.5)
					then validCandidates := validCandidates union {user};
				return validCandidates
				);

public acceptAppliance : User ==> ()
acceptAppliance(u) == 
(
		removeAppliance(u);
		openPositions := openPositions - 1;
		u.acceptedJob(self);
);

public declineAppliance : User ==> ()
declineAppliance(u) == 
(
		removeAppliance(u);
		u.declinedJob(self)
);


functions

public areEqual : JobOffer * JobOffer -> bool
areEqual(j1, j2) ==
		j1.company = j2.company and j1.position = j2.position and
		j1.neededSkills = j2.neededSkills and j1.requiredEducation = j2.requiredEducation and
		j1.requiredDriversLicense = j2.requiredDriversLicense;

end JobOffer